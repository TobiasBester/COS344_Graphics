<!DOCTYPE html>
    <head>
        <!--script>var exports = {};</script>
        <script type="text/javascript" src="scripts/require.js"></script>
        <!--script type="text/javascript" src="gl-matrix.js"></script-->
        <script type="text/javascript" src="scripts/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="scripts/webgl-utils.js"></script>
        <script type="text/javascript">
            var gl;
            function intiGL(canvas) {
                try {
                    gl = canvas.getContext("webgl");
                    gl.viewportWidth = canvas.width;
                    gl.viewportHeight = canvas.height;
                }
                catch(e){

                }
                if (!gl){
                    alert("Could not initialise WebGL!");
                }
            }
        </script>
        <script id="shader-vs" type="x-shader/x-vertex">
            // #extension GL_OES_standard_derivatives : enable
            attribute vec3 vertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            uniform mat3 uNMatrix;

            varying vec3 vLightWeighting;
            varying vec3 vNormal;
            varying vec4 vPosition;
            varying highp vec2 vTextureCoord;

            void main(void) {
                vPosition = uMVMatrix * vec4(vertexPosition, 1.0);
                gl_Position = uPMatrix * vPosition;
                vTextureCoord = aTextureCoord;
                vec3 transformedNormal = uNMatrix * aVertexNormal;

                /*
                if (bumpOn) {
                    transformedNormal = normalize(texture2D(uNormalTex, vTextureCoord).rgb*2.0 - 1.0);
                }*/

                vNormal = transformedNormal;

            }
        </script>
        <script id="shader-fs" type="x-shader/x-fragment">
            // #extension GL_OES_standard_derivatives : enable
            precision mediump float;

            varying vec3 vLightWeighting;
            varying vec3 vNormal;
            varying vec2 vTextureCoord;
            varying vec4 vPosition;

            uniform sampler2D uSampler;
            uniform sampler2D uNormalTex;
            
            uniform float uShininess;

            uniform vec3 uAmbientColor;
            uniform vec3 uLightingDirection;
            uniform vec3 uDirectionalColor;
            uniform vec3 uSpecularColor;

            uniform float uAlpha;
            uniform bool alphaOn;
            uniform bool bumpOn;

            void main(void){
                vec3 lightWeighting;

                vec3 lightDirection = normalize(uLightingDirection - vPosition.xyz);

                vec3 normal = normalize(vNormal);

                if (bumpOn) {
                    normal = normalize(texture2D(uNormalTex, vTextureCoord).rgb*2.0 - 1.0);
                }

                float specularLightWeighting = 0.0;
                float diffuseLightWeighting = 0.0;
                
                vec3 eyeDirection = normalize(-vPosition.xyz);
                vec3 reflectionDirection = reflect(-lightDirection, normal);

                specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uShininess);                
                diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);

                lightWeighting = uAmbientColor + uSpecularColor * specularLightWeighting + uDirectionalColor * diffuseLightWeighting;
                
                vec4 fragmentColor;
                
                fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

                if (alphaOn) {
                    gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a * uAlpha);
                } else {
                    gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, 1.0);
                }
                

            }
        </script>
        <script type="text/javascript">
            function getShader(gl, id){
                var shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }
                var str ="";
                var k = shaderScript.firstChild;
                while(k){
                    if (k.nodeType == 3){
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }
            

                var shader;
                if (shaderScript.type == "x-shader/x-fragment"){
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-vertex") {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else {
                    return null;
                }

                gl.shaderSource(shader,str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }
        </script>
        <script>    //Shaders
            var shader_program;
            function initShaders(){
                var fragmentShader = getShader(gl, "shader-fs");
                var vertexShader = getShader(gl, "shader-vs");

                shader_program = gl.createProgram();
                gl.attachShader(shader_program, vertexShader);
                gl.attachShader(shader_program,fragmentShader);
                gl.linkProgram(shader_program);

                if (!gl.getProgramParameter(shader_program, gl.LINK_STATUS)){
                    alert("Could_not_initialise_shaders");
                }

                gl.useProgram(shader_program);
                
                shader_program.vertexPositionAttribute = gl.getAttribLocation(shader_program,"vertexPosition");
                gl.enableVertexAttribArray(shader_program.vertexPositionAttribute);
                shader_program.vertexNormalAttribute = gl.getAttribLocation(shader_program,"aVertexNormal");
                gl.enableVertexAttribArray(shader_program.vertexNormalAttribute);
                shader_program.textureCoord = gl.getAttribLocation(shader_program,"aTextureCoord");
                gl.enableVertexAttribArray(shader_program.textureCoord);

                shader_program.pMatrixLocation = gl.getUniformLocation(shader_program,"uPMatrix");
                shader_program.mvMatrixLocation = gl.getUniformLocation(shader_program, "uMVMatrix");
                shader_program.nMatrixUniform = gl.getUniformLocation(shader_program, "uNMatrix");
                shader_program.ambientColorUniform = gl.getUniformLocation(shader_program, "uAmbientColor");
                shader_program.lightingDirectionUniform = gl.getUniformLocation(shader_program, "uLightingDirection");
                shader_program.directionalColorUniform = gl.getUniformLocation(shader_program, "uDirectionalColor");
                shader_program.specularColorUniform = gl.getUniformLocation(shader_program, "uSpecularColor");
                shader_program.uSampler = gl.getUniformLocation(shader_program, 'uSampler');
                shader_program.uNormalTex = gl.getUniformLocation(shader_program, 'uNormalTex');
                shader_program.alphaUniform = gl.getUniformLocation(shader_program, "uAlpha");
                shader_program.shininessUniform = gl.getUniformLocation(shader_program, "uShininess");
                shader_program.useAlpha = gl.getUniformLocation(shader_program, "alphaOn");
                shader_program.useBumpMapping = gl.getUniformLocation(shader_program, "bumpOn");
            }
        </script>
        <script>    //Textures
            var treeTexture;
            var treeNormTex;
            var forestTexture;
            var grassTexture;
            var biscTexture;
            var bisc2Texture;
            var starTexture;
            var sandTexture;
            var snowTexture;
            var witchTexture;
            var cakeTexture;
            function initTextures() {
                treeTexture = gl.createTexture();
                treeNormTex = gl.createTexture();
                forestTexture = gl.createTexture();
                grassTexture = gl.createTexture();
                biscTexture = gl.createTexture();
                bisc2Texture = gl.createTexture();
                starTexture = gl.createTexture();
                sandTexture = gl.createTexture();
                snowTexture = gl.createTexture();
                witchTexture = gl.createTexture();
                cakeTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, treeTexture);
                gl.bindTexture(gl.TEXTURE_2D, treeNormTex);
                gl.bindTexture(gl.TEXTURE_2D, forestTexture);
                gl.bindTexture(gl.TEXTURE_2D, grassTexture);
                gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                gl.bindTexture(gl.TEXTURE_2D, bisc2Texture);
                gl.bindTexture(gl.TEXTURE_2D, starTexture);
                gl.bindTexture(gl.TEXTURE_2D, sandTexture);
                gl.bindTexture(gl.TEXTURE_2D, snowTexture);
                gl.bindTexture(gl.TEXTURE_2D, witchTexture);
                gl.bindTexture(gl.TEXTURE_2D, cakeTexture);

                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 0, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width,
                                height, border, srcFormat, srcType, pixel);

                treeTexture.image = new Image();
                treeNormTex.image = new Image();
                forestTexture.image = new Image();
                grassTexture.image = new Image();
                biscTexture.image = new Image();
                bisc2Texture.image = new Image();
                sandTexture.image = new Image();
                starTexture.image = new Image();
                snowTexture.image = new Image();
                witchTexture.image = new Image();
                cakeTexture.image = new Image();

                treeTexture.image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, treeTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, treeTexture.image);

                    if (isPowerOf2(treeTexture.image.width) && isPowerOf2(treeTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }

                };

                treeNormTex.image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, treeNormTex);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, treeNormTex.image);

                    if (isPowerOf2(treeNormTex.image.width) && isPowerOf2(treeNormTex.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }

                };

                forestTexture.image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, forestTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, forestTexture.image);

                    if (isPowerOf2(forestTexture.image.width) && isPowerOf2(forestTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                grassTexture.image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, grassTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, grassTexture.image);

                    if (isPowerOf2(grassTexture.image.width) && isPowerOf2(grassTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                starTexture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, starTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, starTexture.image);

                    if (isPowerOf2(starTexture.image.width) && isPowerOf2(starTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                biscTexture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, biscTexture.image);

                    if (isPowerOf2(biscTexture.image.width) && isPowerOf2(biscTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                bisc2Texture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, bisc2Texture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, bisc2Texture.image);

                    if (isPowerOf2(bisc2Texture.image.width) && isPowerOf2(bisc2Texture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                sandTexture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, sandTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, sandTexture.image);

                    if (isPowerOf2(sandTexture.image.width) && isPowerOf2(sandTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                snowTexture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, snowTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, snowTexture.image);

                    if (isPowerOf2(snowTexture.image.width) && isPowerOf2(snowTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                witchTexture.image.onload = function () {
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.bindTexture(gl.TEXTURE_2D, witchTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, witchTexture.image);

                    if (isPowerOf2(witchTexture.image.width) && isPowerOf2(witchTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }
                };

                cakeTexture.image.onload = function () {
                    gl.bindTexture(gl.TEXTURE_2D, cakeTexture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, cakeTexture.image);

                    if (isPowerOf2(cakeTexture.image.width) && isPowerOf2(cakeTexture.image.height)) {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.bindTexture(gl.TEXTURE_2D, null);
                    }

                };

                treeTexture.image.src = "./assets/bark/Stylized_Bark_001_COLOR.jpg";
                treeNormTex.image.src = "./assets/bark/Stylized_Bark_001_NORM.jpg";
                forestTexture.image.src = "./assets/forest/forest-background.jpg";
                grassTexture.image.src = "./assets/forest/forest-floor-terrain_0046_01_S_enl.jpg";
                biscTexture.image.src = "./assets/biscuit/biscuit.jpg";
                bisc2Texture.image.src = "./assets/biscuit/biscuit2.jpg";
                starTexture.image.src = "./assets/star.gif";
                sandTexture.image.src = "./assets/sand/Sand 002_COLOR.jpg";
                snowTexture.image.src = "./assets/snow/TexturesCom_Snow0157_3_seamless_S.jpg";
                witchTexture.image.src = "./assets/spooky/witch.png";
                cakeTexture.image.src = "./assets/cake.jpeg";                  
            }

            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
            }
        </script>
        <script>
            var mvMatrix = mat4.create();
            var mvMatrixStack = [];
            var pMatrix = mat4.create();

            function mvPushMatrix(){
                var copy = mat4.create();
                mat4.set(mvMatrix, copy);
                mvMatrixStack.push(copy);
            }

            function mvPopMatrix(){
                if (mvMatrixStack.length == 0){
                    throw "Invalid popMatrix!";
                }
                mvMatrix = mvMatrixStack.pop();
            }

            function degToRoad(degrees){
                return degrees * Math.PI/ 180;
            }

            function setMatrixUniforms() {
                gl.uniformMatrix4fv(shader_program.pMatrixLocation, false, pMatrix);
                gl.uniformMatrix4fv(shader_program.mvMatrixLocation, false, mvMatrix);

                var normalMatrix = mat3.create();
                mat4.toInverseMat3(mvMatrix, normalMatrix);
                mat3.transpose(normalMatrix);
                gl.uniformMatrix3fv(shader_program.nMatrixUniform, false, normalMatrix);
            }

            var roofVertexPositionBuffer;
            var roofVertexIndexBuffer;
            var pyrVertexTextureCoordBuffer;
            var roofVertexNormalBuffer;

            var houseVertexPositionBuffer;
            var cubeVertexIndexBuffer;
            var cubeVertexNormalBuffer;
            var cubeVertexTextureCoordBuffer;

            var sphereVertexPositionBuffer;
            var sphereVertexNormalBuffer;
            var sphereVertexTextureCoordBuffer;
            var sphereVertexIndexBuffer;

            var starVertexPositionBuffer;
            var starVertexTextureCoordBuffer;

            function initBuffers() {
                roofVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
                var vertices = [
                    // Front face
                    0.0,  1.0,  0.0,
                    -1.0, -1.0,  1.0,
                    1.0, -1.0,  1.0,
                    // Right face
                    0.0,  1.0,  0.0,
                    1.0, -1.0,  1.0,
                    1.0, -1.0, -1.0,
                    // Back face
                    0.0,  1.0,  0.0,
                    1.0, -1.0, -1.0,
                    -1.0, -1.0, -1.0,
                    // Left face
                    0.0,  1.0,  0.0,
                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                roofVertexPositionBuffer.itemSize = 3;
                roofVertexPositionBuffer.numItems = 12;

                pyrVertexTextureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, pyrVertexTextureCoordBuffer);
                var textureCoords = [
                    // Front Face
                     0.0,  0.5,       // Top point
                     0.0,  0.0,       // BottomLeft point
                     1.0,  0.0,       // BottomRight point

                    // Right Face
                     0.0,  0.5,       // Top point
                     0.0,  0.0,       // BottomLeft point
                     1.0,  0.0,       // BottomRight point

                     // Back Face
                     0.0,  0.5,       // Top point
                     0.0,  0.0,       // BottomLeft point
                     1.0,  0.0,       // BottomRight point

                     // Left Face
                     0.0,  0.5,       // Top point
                     0.0,  0.0,       // BottomLeft point
                     1.0,  0.0,       // BottomRight point

                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                pyrVertexTextureCoordBuffer.itemSize = 2;
                pyrVertexTextureCoordBuffer.numItems = 12;

                roofVertexNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexNormalBuffer);
                var vertexRNormals = [
                    // Front face
                    0.0, 0.0,  1.0,
                    0.0, 0.0,  1.0,
                    0.0, 0.0,  1.0,
                    // Right face
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,
                    // Back face
                    0.0, 0.0,  -1.0,
                    0.0, 0.0,  -1.0,
                    0.0, 0.0,  -1.0,
                    // Left face
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexRNormals), gl.STATIC_DRAW);
                roofVertexNormalBuffer.itemSize = 3;
                roofVertexNormalBuffer.numItems = 12;

                /*
                roofVertexIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexIndexBuffer);
                var indices = [
                    0, 3, 1,
                    1, 3, 2,
                    2, 3, 0,
                    0, 1, 2
                ];
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                roofVertexIndexBuffer.itemSize = 1;
                roofVertexIndexBuffer.numItems = 12;*/

                houseVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER,houseVertexPositionBuffer);
                vertices = [
                    // Front face
                    -1.0, -1.0,  1.0,
                    1.0, -1.0,  1.0,
                    1.0,  1.0,  1.0,
                    -1.0,  1.0,  1.0,

                    // Back face
                    -1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    1.0,  1.0, -1.0,
                    1.0, -1.0, -1.0,

                    // Top face
                    -1.0,  1.0, -1.0,
                    -1.0,  1.0,  1.0,
                    1.0,  1.0,  1.0,
                    1.0,  1.0, -1.0,

                    // Bottom face
                    -1.0, -1.0, -1.0,
                    1.0, -1.0, -1.0,
                    1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,

                    // Right face
                    1.0, -1.0, -1.0,
                    1.0,  1.0, -1.0,
                    1.0,  1.0,  1.0,
                    1.0, -1.0,  1.0,

                    // Left face
                    -1.0, -1.0, -1.0,
                    -1.0, -1.0,  1.0,
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                houseVertexPositionBuffer.itemSize = 3;
                houseVertexPositionBuffer.numItems = 24;

                //Define element array buffer
                cubeVertexIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                var cubeVertexIndices = [
                    0, 1, 2,      0, 2, 3,    // Front face
                    4, 5, 6,      4, 6, 7,    // Back face
                    8, 9, 10,     8, 10, 11,  // Top face
                    12, 13, 14,   12, 14, 15, // Bottom face
                    16, 17, 18,   16, 18, 19, // Right face
                    20, 21, 22,   20, 22, 23  // Left face
                ]
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
                cubeVertexIndexBuffer.itemSize = 1;
                cubeVertexIndexBuffer.numItems = 36;

                //cube vertex Normal buffers
                cubeVertexNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                var vertexNormals = [
                    // Front face
                    0.0, 0.0,  1.0,
                    0.0, 0.0,  1.0,
                    0.0, 0.0,  1.0,
                    0.0, 0.0,  1.0,

                    // Back face
                    0.0, 0.0, -1.0,
                    0.0, 0.0, -1.0,
                    0.0, 0.0, -1.0,
                    0.0, 0.0, -1.0,

                    // Top face
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,
                    0.0, 1.0,  0.0,

                    // Bottom face
                    0.0, -1.0, 0.0,
                    0.0, -1.0, 0.0,
                    0.0, -1.0, 0.0,
                    0.0, -1.0, 0.0,

                    // Right face
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,
                    1.0, 0.0,  0.0,

                    // Left face
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0,
                    -1.0, 0.0,  0.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
                cubeVertexNormalBuffer.itemSize = 3;
                cubeVertexNormalBuffer.numItems = 24;

                cubeVertexTextureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                // These texture coords specify where in Cartesian (x,y) coords the vertex lies in the texture
                var textureCoords = [
                    // Front face - bottomleft image
                    0.0, 0.0,       // bottom left
                    1.0, 0.0,      // bottom right
                    1.0, 1.0,      // top right
                    0.0, 1.0,       // top left
                    
                    // Back Face - bottommright image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                    // Top Face - bottommiddle image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                    // Bottom Face - topleft image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                    // Right Face - topmiddle image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                    // Left Face  - topright image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                cubeVertexTextureCoordBuffer.itemSize = 2;
                cubeVertexTextureCoordBuffer.numItems = 24;

                forestVertexTextureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                // These texture coords specify where in Cartesian (x,y) coords the vertex lies in the texture
                textureCoords = [
                    // Front face - bottomleft image
                    0.0, 0.0,       // bottom left
                    1.0, 0.0,      // bottom right
                    1.0, 1.0,      // top right
                    0.0, 1.0,       // top left
                    
                    // Back Face - bottommright image
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,
                    0.0, 0.0,

                    // Top Face - bottommiddle image
                    0.0, 1.0,
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,

                    // Bottom Face - topleft image
                    1.0, 1.0,
                    0.0, 1.0,
                    0.0, 0.0,
                    1.0, 0.0,

                    // Right Face - topmiddle image
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,
                    0.0, 0.0,

                    // Left Face  - topright image
                    0.0, 0.0,
                    1.0, 0.0,
                    1.0, 1.0,
                    0.0, 1.0,

                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                forestVertexTextureCoordBuffer.itemSize = 2;
                forestVertexTextureCoordBuffer.numItems = 24;

                // SPHERE
                var latitudeBands = 30;
                var longitudeBands = 30;
                var radius = 2;

                var vertexPositionData = [];
                var normalData = [];
                var textureCoordData = [];
                for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
                    var theta = latNumber * Math.PI/ latitudeBands;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);

                    for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                        var phi = longNumber * 2 * Math.PI / longitudeBands;
                        var sinPhi = Math.sin(phi);
                        var cosPhi = Math.cos(phi);

                        var x = cosPhi * sinTheta;
                        var y = cosTheta;
                        var z = sinPhi * sinTheta;
                        var u = 1 - (longNumber/longitudeBands);
                        var v = 1 - (latNumber/latitudeBands);

                        normalData.push(x);
                        normalData.push(y);
                        normalData.push(z);
                        textureCoordData.push(u);
                        textureCoordData.push(v);
                        vertexPositionData.push(radius * x);
                        vertexPositionData.push(radius * y);
                        vertexPositionData.push(radius * z);
                    }
                }

                var indexData = [];
                for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
                    for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                        var first = (latNumber * (longitudeBands + 1)) + longNumber;
                        var second = first + longitudeBands + 1;
                        indexData.push(first);
                        indexData.push(second);
                        indexData.push(first + 1);

                        indexData.push(second);
                        indexData.push(second + 1);
                        indexData.push(first + 1);
                    }
                }

                sphereVertexNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
                sphereVertexNormalBuffer.itemSize = 3;
                sphereVertexNormalBuffer.numItems = normalData.length / 3;

                sphereVertexTextureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexTextureCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
                sphereVertexTextureCoordBuffer.itemSize = 2;
                sphereVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

                sphereVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
                sphereVertexPositionBuffer.itemSize = 3;
                sphereVertexPositionBuffer.numItems = vertexPositionData.length / 3;

                sphereVertexIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereVertexIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
                sphereVertexIndexBuffer.itemSize = 1;
                sphereVertexIndexBuffer.numItems = indexData.length; 

                starVertexPositionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, starVertexPositionBuffer);
                vertices = [
                    -1.0, -1.0, 0.0,
                     1.0, -1.0, 0.0,
                    -1.0,  1.0, 0.0,
                     1.0,  1.0, 0.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                starVertexPositionBuffer.itemSize = 3;
                starVertexPositionBuffer.numItems = 4;

                starVertexTextureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, starVertexTextureCoordBuffer);
                textureCoords = [
                    0.0, 0.0,
                    1.0, 0.0,
                    0.0, 1.0,
                    1.0, 1.0
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                starVertexTextureCoordBuffer.itemSize = 2;
                starVertexTextureCoordBuffer.numItems = 4;

            }

            var rRoof1 = 0;       //used to track rotation
            var rHouse1 = 0;
            var rRoof2 = 0;       //used to track rotation
            var rHouse2 = 0;
            var rRoof3 = 0;       //used to track rotation
            var rHouse3 = 0;
            var rRoof4 = 0;       //used to track rotation
            var rHouse4 = 0;


            function drawScene() {

                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // document.getElementById("theta").step = "3";
                // document.getElementById("phi").step = "3";
                theta = 30;
                phi = 30;

                pMatrix = createIDMatrix();

                if (projection == 1) {
                    createOrthographic(-4, 4, -4, 4, 0, 100);  
                } else {
                    createPerspective(45, gl.viewportWidth/ gl.viewportHeight, 0.1, 100.0);    
                }

                //createOrthographic(-4, 4, -4, 4, 0, 100);
                //mat4.ortho(-4, 4, -4, 4, 0, 100, pMatrix);
                //createPerspective(45, gl.viewportWidth/ gl.viewportHeight, 0.1, 100.0);
                //mat4.perspective(45, gl.viewportWidth/ gl.viewportHeight, 0.1, 100.0, pMatrix);

                //mat4.identity(mvMatrix);
                function createIDMatrix() {
                    return new Float32Array (
                        [1, 0, 0, 0,
                         0, 1, 0, 0,
                         0, 0, 1, 0,
                         0, 0, 0, 1]
                    );
                }

                mvMatrix = createIDMatrix();
                
                hz1 = -6.0;
                hz2 = -10.0;
                hz3 = -14.0;
                hz4 = -8.0;
                xDir = -(xDirec);
                yDir = -(yDirec);
                zDir = -(zDirec);

                var blending = false;
                var useBumpMapping = false;
                gl.uniform1i(shader_program.useAlpha, blending);
                gl.uniform1f(shader_program.shininessUniform, 32.0);

                ////////////////////////////////////
                
                forestSetup();

                houseSetup();

                decorSetup();

                ///////////////////////////
                /////     STARS    ////////
                ///////////////////////////
                var twinkle = true;
                for (var i in stars) {
                    if (!bTrigger) {
                        stars[i].draw(tilt, spin, twinkle);
                        spin += 0.1;
                    }
                }

                function forestSetup() {
                    ///////////////////////////
                    /////   FOREST Back   //////
                    ///////////////////////////
                    mvPushMatrix();

                    /*    translate(-2.0, 0.0, hz1);       
                    rotateX(0);
                    rotateY(40); */    

                    translate(-xPos, -yPos + 2.9, -zPos - 16.0);
                    rotateX(-pitch);
                    if (-yaw >= -0.53 && -yaw <= 0.53) {
                        rotateY(-yaw / 2);
                    } else if (-yaw < -0.53) {
                        rotateY(-0.53/2);
                    } else {
                        rotateY(0.53/2);
                    }
                    
                    scale(10.0, 4.0, 1.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, forestTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.1);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.15, 0.15, 0.15);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8274, 0.8274, 0.8274 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    var forestBounds = 0.53;
                    ///////////////////////////
                    /////   FOREST Left   //////
                    ///////////////////////////
                    mvPushMatrix();

                    /*    translate(-2.0, 0.0, hz1);       
                    rotateX(0);
                    rotateY(40); */    

                    translate(-xPos - 6.0, -yPos + 2.9, -zPos - 8.0);
                    rotateX(-pitch);
                    if (-yaw >= -forestBounds && -yaw <= forestBounds) {
                        rotateY(-yaw);
                    } else if (-yaw < -forestBounds) {
                        rotateY(-forestBounds);
                    } else {
                        rotateY(forestBounds);
                    }
                    
                    scale(1.0, 4.0, 8.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, forestTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.1);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.15, 0.15, 0.15);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8274, 0.8274, 0.8274 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////   FOREST Right   //////
                    ///////////////////////////
                    mvPushMatrix();

                    /*    translate(-2.0, 0.0, hz1);       
                    rotateX(0);
                    rotateY(40); */    

                    translate(-xPos + 6.0, -yPos + 2.9, -zPos - 8.0);
                    rotateX(-pitch);
                    if (-yaw >= -forestBounds && -yaw <= forestBounds) {
                        rotateY(-yaw);
                    }  else if (-yaw < -forestBounds) {
                        rotateY(-forestBounds);
                    } else {
                        rotateY(forestBounds);
                    }
                    
                    scale(1.0, 4.0, 8.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, forestTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.1);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.15, 0.15, 0.15);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8274, 0.8274, 0.8274 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////

                    ///////////////////////////
                    /////     FLOOR    ////////
                    ///////////////////////////
                    mvPushMatrix();

                    translate(-xPos, -yPos - 0.5, -zPos - 8.0);
                    rotateX(-pitch);
                    if (-yaw >= -forestBounds && -yaw <= forestBounds) {
                        rotateY(-yaw);
                    }  else if (-yaw < -forestBounds) {
                        rotateY(-forestBounds);
                    } else {
                        rotateY(forestBounds);
                    }
                    
                    scale(6.0,0.1,8.0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, grassTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.1, 0.1, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.5, 0.5, 0.5 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                }

                function houseSetup() {

                    ///////////////////////////
                    ///////   Log   ///////////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = true;
                    /*    translate(-2.0, 0.0, hz1);       
                    rotateX(0);
                    rotateY(40); */    

                    translate(-xPos + 3.0, -yPos + 1.0, -zPos - 6.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    shearX(30);

                    scale(0.4, 2.0, 0.4);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                        
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                        
                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.5, 0.5, 1.0);
                    gl.uniform3f(shader_program.specularColorUniform, 0.8, 0.8, 0.8);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8274, 0.8274, 0.8274 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, treeNormTex);
                    gl.uniform1i(shader_program.uNormalTex, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, forestVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, treeTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.1);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();    
  
                    
                    ///////////////////////////
                    /////     HOUSE FLOOR  ////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos - 1.0, -yPos - 0.49, -zPos - 8.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(3.1,0.1,3.6);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, sandTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.1, 0.1, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.5, 0.5, 0.5 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Back Wall  //////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos - 0.8, -yPos + 0.7, -zPos - 11.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(3.4,1.2,0.1);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Right Wall  //////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos + 1.8, -yPos + 0.7, -zPos - 8.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(0.1,1.2,3.2);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Left Wall  //////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos - 3.35, -yPos + 0.7, -zPos - 8.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(0.1,1.2,3.2);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Front Wall  /////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos - 1.8, -yPos + 0.7, -zPos - 4.8);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(1.4,1.2,0.1);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, biscTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     ROOF 1   ////////
                    ///////////////////////////
                    
                    mvPushMatrix();
                    
                    translate(-xPos + -1.0, -yPos + 2.65, -zPos - 7.5);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    scale(3.2,1.0,3.2);

                    gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, roofVertexPositionBuffer.itemSize, gl.FLOAT,false,0,0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, roofVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, pyrVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    pyrVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);    
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, snowTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.6);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }
                    

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.1, 0.1, 0.1);
                    
                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8274, 0.8274, 0.8274 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                    0.0, 0.0, 0.0 );
                    }

                    setMatrixUniforms();
                    gl.drawArrays(gl.TRIANGLES, 0, roofVertexPositionBuffer.numItems);
                
                    mvPopMatrix();

                    ///////////////////////////////////////////////////////////////
                }
            
                function decorSetup() {
                    ///////////////////////////
                    /////     Magic Door  /////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos + 0.5 - doorPos, -yPos + 0.7, -zPos - 4.85);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(1.3,1.1,0.1);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, bisc2Texture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////

                    ///////////////////////////
                    /////     Witch  //////////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos + 0.0, -yPos + 0.4, -zPos -10.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(0.5,0.7,0.2);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, witchTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = bTrigger;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.6);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.8, 0.8, 0.8 );
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Witch Brim  //////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos + 0.0, -yPos + 1.1, -zPos -10.0);
                    rotateX(-pitch+15);
                    rotateY(-yaw);
                    
                    scale(0.7,0.01,0.3);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, witchTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 1.0);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.0, 0.0, 0.0);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                        0.0, 0.0, 0.0);
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                    ///////////////////////////
                    /////     Witch hat  //////
                    ///////////////////////////
                    
                    mvPushMatrix();
                    
                    translate(-xPos + 0.0, -yPos + 1.5, -zPos -10.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    scale(0.4,0.5,0.4);

                    gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, roofVertexPositionBuffer.itemSize, gl.FLOAT,false,0,0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, roofVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, roofVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, pyrVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    pyrVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);    
                    
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, witchTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.6);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }
                    

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.1, 0.1, 0.1);
                    
                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );   // LightGrey
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                    0.0, 0.0, 0.0 );
                    }

                    setMatrixUniforms();
                    gl.drawArrays(gl.TRIANGLES, 0, roofVertexPositionBuffer.numItems);
                
                    mvPopMatrix();

                    ///////////////////////////////////////////////////////////////
                    ///////////////////////////
                    /////     Cake    /////////
                    ///////////////////////////
                    mvPushMatrix();

                    useBumpMapping = false;

                    translate(-xPos + 1.0, -yPos + 0.1, -zPos -8.0);
                    rotateX(-pitch);
                    rotateY(-yaw);
                    
                    scale(0.5,0.5,0.5);

                    gl.bindBuffer(gl.ARRAY_BUFFER, houseVertexPositionBuffer);
                    gl.vertexAttribPointer(shader_program.vertexPositionAttribute, houseVertexPositionBuffer.itemSize, gl.FLOAT, false,0,0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
                    gl.vertexAttribPointer(shader_program.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
                    gl.vertexAttribPointer(shader_program.textureCoord, 
                    cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, cakeTexture);
                    gl.uniform1i(shader_program.uSampler, 0);

                    blending = false;
                    if (blending) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        gl.enable(gl.BLEND);
                        gl.disable(gl.DEPTH_TEST);
                        gl.uniform1f(shader_program.alphaUniform, 0.6);
                    } else {
                        gl.disable(gl.BLEND);
                        gl.enable(gl.DEPTH_TEST);
                    }

                    lights = vec3.normalize([xDir, yDir, zDir]);
                    vec3.scale(lights, -1);
                    gl.uniform3fv(shader_program.lightingDirectionUniform, lights);
                    gl.uniform3f(shader_program.directionalColorUniform, 0.2, 0.2, 0.1);

                    aChecked = true;
                    if (aChecked) {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                cakeR, cakeG, cakeB);
                    } else {
                        gl.uniform3f(shader_program.ambientColorUniform, 
                                0.0, 0.0, 0.0 );
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
                    setMatrixUniforms();
                    gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

                    mvPopMatrix();

                    //////////////////////////////////////
                }
            }

        </script>
        <script>
            //Translate Function
            function translate(a,b,c){
                translateMatrix = [
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    a, b, c, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Rotate along Z-axis Function
            function rotateZ(theta){
                translateMatrix = [
                    Math.cos(theta), Math.sin(theta), 0.0, 0.0,
                    -Math.sin(theta), Math.cos(theta), 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Rotate along Y-axis Function
            function rotateY(theta){
                translateMatrix = [
                    Math.cos(theta), 0.0, -Math.sin(theta), 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    Math.sin(theta), 0.0, Math.cos(theta), 0.0,
                    0.0, 0.0, 0.0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Rotate along X-axis Function
            function rotateX(theta){
                translateMatrix = [
                    1.0, 0.0, 0.0, 0.0,
                    0.0, Math.cos(theta), Math.sin(theta), 0.0,
                    0.0, -Math.sin(theta), Math.cos(theta), 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Scale Function
            function scale(betaX,betaY,betaZ){
                translateMatrix = [
                    betaX, 0.0, 0.0, 0.0,
                    0.0, betaY, 0.0, 0.0,
                    0.0, 0.0, betaZ, 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Shear along X Axis Function
            function shearX(theta){
                translateMatrix = [
                    1.0, 0.0, 0.0, 0.0,
                    1/Math.tan(theta), 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Shear along Y Axis Function
            function shearY(theta){
                translateMatrix = [
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 1/Math.tan(theta), 1.0, 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }

            //Shear along Z Axis Function
            function shearZ(theta){
                translateMatrix = [
                    1.0, 0.0, 1/Math.tan(theta), 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0, 0, 0, 1.0
                ];

                mat4.multiply(mvMatrix, translateMatrix);
            }
        </script>
        <script>
            var stars = [];

            function initWorldObjects() {
                var numStars = 10;

                for (var i = 0; i < numStars; i++) {
                    stars.push(new Star(0.0, i / (numStars * 50) ));
                }
            }

            var zoom = -15;
            var tilt = 90;
            var spin = 0;

            function Star(startingDistance, rotationSpeed) {
                this.angle = 0;
                this.dist = startingDistance;
                this.rotationSpeed = rotationSpeed;

                this.randomiseColors();
            }

            Star.prototype.draw = function(tilt, spin, twinkle) {
                mvPushMatrix();

                scale(0.5, 0.5, 0.5);
                rotateY(this.angle);
                translate(this.dist, 0.4, -10.0);

                rotateY(-this.angle);
                rotateX(-tilt);

                if (twinkle) {
                    gl.uniform3f(shader_program.ambientColorUniform, this.twinkleR, this.twinkleG, this.twinkleB);
                    drawStar();
                }

                rotateZ(spin);
                gl.uniform3f(shader_program.ambientColorUniform, this.r, this.g, this.b);
                drawStar();

                mvPopMatrix();
            }

            var effectiveFPMS = 60 / 1000;
            Star.prototype.animate = function(elapsedTime) {
                this.angle += ( this.rotationSpeed ) * effectiveFPMS * elapsedTime;

                this.dist -= 0.01 * effectiveFPMS * elapsedTime;
                if (this.dist < 0.0) {
                    this.dist += 10.0;
                    this.randomiseColors();
                }
            }

            Star.prototype.randomiseColors = function () {
                this.r = Math.random();
                this.b = Math.random();
                this.g = Math.random();

                this.twinkleR = Math.random();
                this.twinkleB = Math.random();
                this.twinkleG = Math.random();
            }

            function drawStar() {
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, starTexture);
                gl.uniform1i(shader_program.uSampler, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, starVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shader_program.textureCoord,
                starVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, starVertexPositionBuffer);
                gl.vertexAttribPointer(shader_program.vertexPositionAttribute,
                starVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                setMatrixUniforms();
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, starVertexPositionBuffer.numItems );
            }
        </script>
        <script>    // tick and animate
            function tick(){
                requestAnimFrame(tick);
                handleKeys();
                drawScene();
                animate();
            }

            var lastTime = 0;
            var joggingAngle = 0;
            function animate(){
                var timeNow = new Date().getTime();
                if (lastTime != 0){
                    var elapsed = timeNow - lastTime;

                    if (speed != 0) {
                        xPos -= Math.sin(degToRoad(yaw)) * speed * elapsed;
                        if (zPos <= 1.26) {
                            zPos -= Math.cos(degToRoad(yaw)) * speed * elapsed;
                        }

                        joggingAngle += elapsed * 0.5;
                        yPos = Math.sin(degToRoad(joggingAngle))/ 20 + 0.4;
                    }

                    yaw += yawRate * elapsed;
                    pitch += pitchRate * elapsed;
                  
                   for (var i in stars) {
                       stars[i].animate(elapsed);
                   }
                }
                lastTime = timeNow;
            }
        </script>
        <script>    // handleKeyPress
            var currentlyPressedKeys = {};
            var pitch = 0;
            var pitchRate = 0.0;
            var yaw = 0;
            var yawRate = 0;

            var xPos = 0;
            var doorPos = 0.0;
            var bTrigger = true;
            var yPos = 0.4;
            var zPos = 0;
            var speed = 0;

            var xDirec = -4.3;
            var yDirec = 4.0;
            var zDirec = 1.5;

            function handleKeyDown(event) {
                currentlyPressedKeys[event.keyCode] = true;
            }

            function handleKeyUp(event) {
                currentlyPressedKeys[event.keyCode] = false;
            }

            function handleKeys() {
                if (currentlyPressedKeys[33]) {
                    pitchRate = 0.001;
                } else if (currentlyPressedKeys[34]) {
                    pitchRate = -0.001;
                } else {
                    pitchRate = 0;
                }

                if (currentlyPressedKeys[37]) {         // Left
                    yawRate = 0.001;
                } else if (currentlyPressedKeys[39]) {  // Right
                    yawRate = -0.001;
                } else {
                    yawRate = 0;
                }

                if (currentlyPressedKeys[38]) {         // Forward (up)
                    if (zPos < -4.1) {
                        speed = 0.0005;
                        bTrigger = false;
                    } else {
                        speed = 0.003;
                    }
                    doorPos += 0.05;
                } else if (currentlyPressedKeys[40]) {  // Backward (down)
                    speed = -0.003;;
                    doorPos -= 0.05;
                } else {
                    speed = 0;
                }

                if (currentlyPressedKeys[65]) {         // A
                    xDirec -= 0.05;
                } else if (currentlyPressedKeys[68]) {  // D
                    xDirec += 0.05;
                } else {
                    xDirec += 0;
                }

                if (currentlyPressedKeys[87]) {         // W
                    yDirec += 0.05;
                } else if (currentlyPressedKeys[83]) {  // S
                    yDirec -= 0.05;
                } else {
                    yDirec += 0;
                }

                if (currentlyPressedKeys[82]) {         // R
                    zDirec += 0.05;
                } else if (currentlyPressedKeys[70]) {  // F
                    zDirec -= 0.05;
                } else {
                    zDirec += 0;
                }

                if (currentlyPressedKeys[79]) {         // O
                    if (projection == 1 ) {
                        projection = 0;
                    } else {
                        projection = 1;
                    }
                }
            }

            var mDown = false;
            var cakeR = 0.5;
            var cakeG = 0.3;
            var cakeB = 0.1;
            var downR = false;
                var downB = false;
                var downG = true;

            function handleMDown(event) {
                mDown = true;
                console.log(cakeR);
            }

            function handleMUp(event) {
                mDown = false;
            }

            function handleMMove(event) {
                if (!mDown) {
                    return;
                }

                if (cakeR >= 1.0) {
                    downR = true;
                }
                if (cakeR <= 0.0) {
                    downR = false;
                }
                if (cakeB >= 1.0) {
                    downB = true;
                }
                if (cakeB <= 0.0) {
                    downB = false;
                }
                if (cakeG >= 1.0) {
                    downG = true;
                }
                if (cakeG <= 0.0) {
                    downG = false;
                }

                if (!downR) {
                    cakeR += 0.01;
                } else {
                    cakeR -= 0.01;
                }
                if (!downG) {
                    cakeG += 0.01;
                } else {
                    cakeG -= 0.01;
                }
                if (!downB) {
                    cakeB += 0.01;
                } else {
                    cakeB -= 0.01;
                }

            }
            
            var projection = 0;
        </script>
        <script>    // Projection Functions
            function createOrthographic(left, right, bottom, top, near, far) {
                mid_x = (left + right)/2;
                mid_y = (bottom + top)/2;
                mid_z = (-near + -far)/2;
/*
                centerAboutOrigin = [
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    -mid_x, -mid_y, -mid_z, 1.0
                ];
                mat4.multiply(pMatrix, centerAboutOrigin);
*/
                scale_x = 2.0/(right - left);
                scale_y = 2.0/(top - bottom);
                scale_z = 2.0/(far-near);
/*
                scaleViewingVolume = [
                    scale_x, 0.0, 0.0, 0.0,
                    0.0, scale_y, 0.0, 0.0,
                    0.0, 0.0, -scale_z, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ];
                mat4.multiply(pMatrix, scaleViewingVolume);*/

                orthoMat = [
                    scale_x, 0.0, 0.0, 0.0,
                    0.0, scale_y, 0.0, 0.0,
                    0.0, 0.0,-scale_z, 0.0,
                    mid_x * -(scale_x), mid_y * -(scale_y), mid_z * (scale_z), 1.0 
                ];

                mat4.multiply(pMatrix, orthoMat);
            }

            function createPerspective(fovy, aspect, near, far) {
                // Fovy cannot be > 180degrees
                // Aspect ratio is width/height
                // near and far > 0
                // near < far
                var top, bottom, left, right;
                top = near * Math.tan(degToRoad(fovy)/2);
                bottom = -top;
                right = top * aspect;
                left = -right;

                createFrustum(left, right, bottom, top, near, far);
            }

            function createFrustum(left, right, bottom, top, near, far) {
                frustum = [
                    (2*near)/(right-left), 0.0, 0.0, 0.0,
                    0.0, (2*near)/(top-bottom), 0.0, 0.0,
                    (right+left)/(right-left), (top+bottom)/(top-bottom), -((far+near)/(far-near)), -1.0,
                    0.0, 0.0, (-2*far*near)/(far-near), 0.0
                ];

                mat4.multiply(pMatrix, frustum);
            }

            function createOblique(theta, phi) {
                cotTheta = 1/Math.tan(theta);
                cotPhi = 1/Math.tan(phi);

                oblique = [
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    cotTheta, cotPhi, 0.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ];

                mat4.multiply(pMatrix, oblique);
            }

        </script>
        <script>
            function webGLStart() {
                var canvas = document.getElementById("webgl-intro");
                intiGL(canvas);
                // gl.getExtension('OES_standard_derivatives');
                initShaders();
                initBuffers();
                initTextures();
                initWorldObjects();

                gl.clearColor(0.1,0.4,0.7,1.0);
                // gl.enable(gl.DEPTH_TEST);

                document.onkeydown = handleKeyDown;
                document.onkeyup = handleKeyUp;

                canvas.onmousedown = handleMDown;
                document.onmouseup = handleMUp;
                document.onmousemove = handleMMove;

                tick();
            }
        </script>
    </head>
    <body onload="webGLStart();">
        <canvas id="webgl-intro" width="1200" height="700"></canvas>
    </body>
</html>